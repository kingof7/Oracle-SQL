--4/8

-- 형식) select [필드/컬럼명 또는 표현식]
--      from [테이블명 또는 뷰명]
--      where 조건절
-- 8. where절 : where 조건절 구성은 컬럼, 연산자, 비교대상 값
-- 8-1) 비교연산자 : =(같다), >, >=, <, <=, <>(같지 않다)


SELECT * FROM EMPLOYEES 
WHERE DEPARTMENT_ID = 90;
--from >> where >> select (우선순위)

SELECT EMPLOYEE_ID,
        SALARY,
        DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID <> 90;

SELECT EMPLOYEE_ID,
        FIRST_NAME,
        SALARY
FROM EMPLOYEES
WHERE SALARY >= 3500;

-- 오라클에서 명령어는 대소문자를 구분하지 않지만, 데이터는 반드시 대소문자 구분한다 ex) 'Smith' <> 'smith'
SELECT EMPLOYEE_ID,
        LAST_NAME
FROM EMPLOYEES
WHERE LAST_NAME='Smith';

SELECT EMPLOYEE_ID,
        HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE >='01/01/01'
-- where hire_date >='2001-01-01' 도 가능
ORDER BY HIRE_DATE;

-- 8-2) 논리연산자 : AND, OR, NOT
-- 1) AND :
-- 직군이 IT_PROG 이면서 부서코드가 60인 사원의 사원번호, 부서코드를 출력하세요
SELECT JOB_ID, DEPARTMENT_ID FROM EMPLOYEES;

SELECT EMPLOYEE_ID, DEPARTMENT_ID
FROM EMPLOYEES
WHERE JOB_ID='IT_PROG' AND DEPARTMENT_ID = 60;

SELECT SALARY FROM EMPLOYEES
ORDER BY SALARY;

-- 연봉이 3000이상이면서 부서코드가 100인 사원의 사원번호, 연봉, 부서코드 출력

SELECT EMPLOYEE_ID, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE SALARY >= 3000 AND DEPARTMENT_ID = 100
ORDER BY SALARY;

-- 연봉이 3000이상이면서 2003-01-01 이후에 입사한 사원번호, 연봉, 입사일 출력
SELECT EMPLOYEE_ID, SALARY, HIRE_DATE
FROM EMPLOYEES
WHERE SALARY >= 3000 AND HIRE_DATE > '03/01/01'
ORDER BY HIRE_DATE;

-- 2) OR
-- 직군이 IT_PROG 이거나 2005-01-01 이후 입사한 사원의 사원번호, 직군, 입사년도 출력

SELECT EMPLOYEE_ID, JOB_ID, HIRE_DATE
FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG' OR HIRE_DATE >= '05/01/01'
ORDER BY HIRE_DATE;

-- 3) NOT / <> 같지않다

SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID <> 90;

SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES
WHERE NOT DEPARTMENT_ID = 90;

-- <> 대신 NOT을 반드시 써야하는 경우 : NULL값을 뽑을때
SELECT EMPLOYEE_ID, DEPARTMENT_ID 
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NULL; -- ~~ = NULL은 올바른 문법이 아니다

SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL;

SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES 
WHERE NOT DEPARTMENT_ID IS NULL;

SELECT EMPLOYEE_ID,
        COMMISSION_PCT
FROM EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL;

-- 8-3) IN(값,값..) 연산자 / BETWEEN VALUE1 AND VALUE2 / LIKE 연산자 %
-- IN(val1, val2, val3 ...)연산자 : va1l 이거나 va12 이거나 va13인 --> OR과 비슷함
--                                 동일한 필드가 여러 개의 값 중에 하나인 경우
--                                 복잡한 쿼리문 사용시 활용하면 간단하게 표현할 수 있다.
--                                 추후 any, some, all, exit 연산자와 함께 서브쿼리 () 에서 사용된다.

SELECT EMPLOYEE_ID,
       COMMISSION_PCT
FROM EMPLOYEES
WHERE COMMISSION_PCT=0.2 OR COMMISSION_PCT=0.1 OR COMMISSION_PCT=0.25; -- 필드1개쓸거면 OR은 가독성이 떨어짐 ↓

SELECT EMPLOYEE_ID,
       COMMISSION_PCT
FROM EMPLOYEES
WHERE COMMISSION_PCT IN(0.2, 0.1, 0.25); --필드가 1개 뿐일때 OR보다는 IN연산자가 가독성이 좋다 // OR 연산자는 필드가 여러개 가능

--직군이 IT_PROG, HR_REP, SH_CLERK, MKREP인 사원의 사원번호와 직군을 출력

SELECT EMPLOYEE_ID, JOB_ID
FROM EMPLOYEES
WHERE JOB_ID IN('IT_PROG', 'HR_REP', 'SH_CLERK', 'MKREP');

-- 부서코드가 10, 90이 아닌 부서코드를 출려
SELECT DEPARTMENT_ID
FROM DEPARTMENTS
WHERE DEPARTMENT_ID NOT IN(10, 90);

SELECT DEPARTMENT_ID
FROM DEPARTMENTS
WHERE DEPARTMENT_ID <> 10 AND DEPARTMENT_ID <> 90;

-- between a AND b : a와 b사이에 있는 범위 값을 모두 검색
-- 연봉이 2000~6000인 사원의 이름과 연봉 출력
SELECT FIRST_NAME || ' ' || LAST_NAME AS EMPLOYEE_NAME, SALARY 
FROM EMPLOYEES
WHERE SALARY BETWEEN 2000 AND 6000
ORDER BY SALARY;

--입사년도가 2003-01-01 ~ 2005.12-31인 사원의 이름, 입사년도 출력
SELECT FIRST_NAME NAME,
       HIRE_DATE
FROM EMPLOYEES
WHERE HIRE_DATE BETWEEN '03/01/01' AND '05/12/31'
ORDER BY HIRE_DATE;

--연봉이 1000~4000 아닌 사원들의 사원번호, 연봉 출력

SELECT EMPLOYEE_ID,
       SALARY
FROM EMPLOYEES
WHERE NOT SALARY BETWEEN 1000 AND 4000
ORDER BY SALARY;

-- 혼합해서 사용
SELECT EMPLOYEE_ID,
       HIRE_DATE
FROM EMPLOYEES
WHERE EMPLOYEE_ID IN(100,110)
AND (HIRE_DATE >= '05/01/01' AND HIRE_DATE <= '10/01/01');
-- AND HIRE_DATE BETWEEN '05/01/01' AND '10/01/01';

-- LIKE 연산자
-- PATTERN: %, _(언더바)
-- 사원이름 K로 시작하는 사원의 이름 출력
SELECT LAST_NAME NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE 'K%';

-- 사원이름 N으로 끝나는 사원의 이름 출력

SELECT LAST_NAME NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE '%n';

-- 사원이름 어딘가에 h 문자열이 있으면 출력

SELECT FIRST_NAME || ' '||LAST_NAME NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE '%h%';

-- 사원이름 중 두 번째 문자가 a인 사원의 이름
SELECT LAST_NAME NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE '_a%';

-- 사원이름 중 세 번째 문자가 a인 사원의 이름
SELECT LAST_NAME NAME
FROM EMPLOYEES
WHERE LAST_NAME LIKE '__a%';

-- 사원이름 중에서 A, a라는 문자를 포함하지 않는 사원의 이름 출력

SELECT LAST_NAME NAME
FROM EMPLOYEES
WHERE LAST_NAME NOT LIKE '%a%' AND LAST_NAME NOT LIKE '%A%';

-- 사원이름 중에서 a로 시작하지 않는 사원의 이름 출력

SELECT LAST_NAME NAME
FROM EMPLOYEES
WHERE LAST_NAME NOT LIKE 'a%';

-- GROUP BY[COLUMN]는 WHERE랑 같이 쓸 수 없음 (단, HAVING절로 대체) 
-- ORDER BY[COLUMN]는 아무곳에나 마지막 줄에 사용 가능

-- 9.ORDER BY [COLUMN]
SELECT FIRST_NAME
FROM EMPLOYEES
ORDER BY FIRST_NAME ASC; -- ASCENDING // DESC : DESCENDING

SELECT FIRST_NAME
FROM EMPLOYEES
ORDER BY FIRST_NAME; -- DEFAULT는 오름차순이다

SELECT FIRST_NAME
FROM EMPLOYEES
ORDER BY FIRST_NAME DESC;

SELECT EMPLOYEE_ID,
       HIRE_DATE
FROM EMPLOYEES
ORDER BY HIRE_DATE ASC;

SELECT EMPLOYEE_ID,
       SALARY
FROM EMPLOYEES
ORDER BY SALARY DESC;

SELECT EMPLOYEE_ID,
       FIRST_NAME,
       SALARY
FROM EMPLOYEES
ORDER BY SALARY DESC, FIRST_NAME ASC; -- SALARY 내림차순 먼저하고, 같은 연봉이 있으면 그 안에서 이름은 오름차순 정렬

SELECT EMPLOYEE_ID,
       SALARY
FROM EMPLOYEES
WHERE SALARY > 5000
ORDER BY SALARY;

SELECT EMPLOYEE_ID,
       FIRST_NAME,
       SALARY
FROM EMPLOYEES
WHERE SALARY >=3000 AND SALARY <= 4000
ORDER BY SALARY DESC, FIRST_NAME ASC;

SELECT EMPLOYEE_ID,
       FIRST_NAME,
       SALARY
FROM EMPLOYEES 
WHERE SALARY >=3000 AND SALARY <= 4000
ORDER BY 3 DESC, 2 ASC; --자바로 데이터를 넘겨줄 때, SYNTAX 에러(필드명이 길 경우)를 방지하기 위해서 이렇게 쓸 수도 있음

--프로시저:사용자 지정 함수
--\\192.168.0.133 공유IP
--OPEN API 사이트 참고











