SELECT * FROM EMPLOYEES; -- 107
SELECT * FROM DEPARTMENTS; -- 27
SELECT * FROM LOCATIONS; -- 23

UPDATE LOCATIONS SET CITY = 'Rome';

-- JOIN
-- RDBMS(Relational DataBase Management System)
-- 관계형 데이터베이스는 일련의 정형화된 테이블 구성된 데이터 항목들의
-- 집합체로서, 다양한 방법으로 접근하거나 조합될 수 있다. 이런 관계를
-- 맺는 방법이 조인(연결고리)이다.

--1. Cross Join : 테이블을 서로 조건없이 연결하여 나열한 것
--107 * 27 = 2889, 아무 의미없는 결합

--2.Equal Join : 가장 많이 사용하는 조인 방법으로 대상이 되는 테이블에 공통적으로 
--               존재하는 컬럼의 값이 일치되는 행을 연결하여 결과를 생성
--               WHERE절에 테이블이 공통된 컬럼을 조인 조건으로 제시한다.

SELECT * FROM EMPLOYEES, DEPARTMENTS
WHERE EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;

SELECT FIRST_NAME, --EMPLOYEES
        EMPLOYEES.DEPARTMENT_ID 부서코드, --모호성 에러를 방지하기 위해서 테이블.컬럼명을 지정해줘야 한다.
        DEPARTMENT_NAME --DEPARTMENTS
FROM EMPLOYEES, DEPARTMENTS
WHERE EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;

--David 사원의 이름, 부서번호, 부서명 검색
SELECT FIRST_NAME,
        EMPLOYEES.DEPARTMENT_ID,
        DEPARTMENT_NAME
FROM EMPLOYEES, DEPARTMENTS
WHERE EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
AND FIRST_NAME='David'
AND EMPLOYEES.DEPARTMENT_ID = 60;

--IT부서 소속 사원의 이름, 부서번호, 부서명, 입사년월일 검색
SELECT  A.FIRST_NAME,
        A.DEPARTMENT_ID,
        B.DEPARTMENT_NAME,
        A.HIRE_DATE
FROM EMPLOYEES A, DEPARTMENTS B --테이블에는 AS 못쓴다
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
AND B.DEPARTMENT_NAME='IT';

--4/13
--부서 90번호를 제외한 사원의 사원명, 부서코드, 부서명 검색
SELECT  A.FIRST_NAME,
        A.DEPARTMENT_ID,
        B.DEPARTMENT_NAME
FROM EMPLOYEES A, DEPARTMENTS B
WHERE A.DEPARTMENT_ID = B.DEPARTMENT_ID
AND A.DEPARTMENT_ID <> 90;

SELECT COUNT(*) FROM EMPLOYEES;

--IT부서과 MAKETING 부서 소속 사원의 이름, 부서번호, 입사일, 부서명

SELECT EMP.FIRST_NAME,
        EMP.DEPARTMENT_ID,
        EMP.HIRE_DATE,
        DEP.DEPARTMENT_NAME
FROM EMPLOYEES EMP, DEPARTMENTS DEP
WHERE EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID
AND DEPARTMENT_NAME IN('IT','Marketing');

-- AND (DEPARTMENT_NAME='IT' OR DEPARTMENT_NAME='MARKETING'); 
-- . > () > 배열 > 부정 > 캐스트 > 산술 (연산자 우선순위)

--부서별 평균연봉
SELECT  DEPARTMENT_ID, 
        TRUNC(AVG(SALARY)),
        COUNT(*)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;

SELECT  DEP.DEPARTMENT_NAME 부서명,
        DEP.DEPARTMENT_ID 부서코드,
        TRUNC(AVG(SALARY)) 평균연봉,
        COUNT(*) 인원수
FROM EMPLOYEES EMP, DEPARTMENTS DEP
WHERE EMP.DEPARTMENT_ID = DEP.DEPARTMENT_ID
GROUP BY DEPARTMENT_NAME, DEP.DEPARTMENT_ID --그룹함수를 제외하고 개별 필드의 갯수와 이름이 일치해야함
ORDER BY 3 ASC;

--2-1) Natural Join : Equal join을 효율적으로 사용하는 한 방법
--형식) ~ FROM 테이블명 Natural Join 테이블명

SELECT *
FROM STUDENT;

SELECT * FROM STUDENT; --학생/ (학생번호),이름,학과,학년,반,성별,키,몸무게
SELECT * FROM ENROL; --수강 / 과목번호, (학생번호), 점수

SELECT *
FROM STUDENT.STU_NO - STATUS_NO
STUDENT,ENROL;


SELECT stu_no,
       welect stu
FROM STUDENT STU, ENROL ENR
WHERE STUDENT_no =ENROL.stu_no;

SELECT STU_NO,
        STU_NAME,
        STU_DEPT,
        ENR_GRADE
FROM STUDENT NATURAL JOIN ENROL; --열이름이 같은 열을 찾아서 조인

SELECT * FROM NATURAL JOIN ENROL;

--NATURAL JOIN 모한다. 그 이유는 두 테이블에 열의 이름이 2개 이상 같은 경우는 사용불가


SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;

DESC EMPLOYEES;

SELECT STU_NO,
        STU_NAME,
        STU_DEPT,
        ENR_GRADE
FROM EMPLOYEES NATURAL JOIN DEPARTMENTS;

--NATURAL USING : 명시적으로 조인할 필드 표시

SELECT * FROM EMPLOYEES NATURAL JOIN DEPARTMENTS; --데이터 107개가 모두 나오지 않음.

SELECT STU_NO,
        STU_NAME,
        STU_DEPT,
        ENR_GRADE
FROM STUDENT NATURAL JOIN ENROL
WHERE STU_NAME='김종헌' OR STU_NAME='유가인';


--형식) ~ FROM 테이블명 Join 테이블명 ON 조건식

SELECT  FIRST_NAME 부서명,
        DEPARTMENT_ID 부서코드,
        DEPARTMENT_NAME 평균연봉
FROM EMPLOYEES JOIN DEPARTMENTS USING(DEPARTMENT_ID)
WHERE DEPARTMENT_NAME IN('IT','Marketing');

-- Join ~ on = Join ~ Using과 같다
-- 형식 ~ FROM 테이블명 JOIN 테이블명 ON 조건식 WHERE ~
SELECT  FIRST_NAME 부서명,
        DEP.DEPARTMENT_ID 부서코드,
        DEPARTMENT_NAME 평균연봉
FROM EMPLOYEES EMP JOIN DEPARTMENTS DEP
ON EMP.DEPARTMENT_ID=DEP.DEPARTMENT_ID
WHERE DEPARTMENT_NAME IN('IT','Marketing');

-- TABLE 3: JOIN 2
SELECT * FROM EMPLOYEES; --(EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, 
                         -- COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID)
SELECT * FROM DEPARTMENTS; --(DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID)
SELECT * FROM LOCATIONS; --(LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, COUNTRY_ID)
SELECT * FROM JOBS; --(JOB_ID, JOB_TITLE, MIN_SALARY, MAX_SALARY)
DESC STUDENT;   --STU_NO     NOT NULL CHAR(9)      
                --STU_NAME            VARCHAR2(12) 
                --STU_DEPT            VARCHAR2(20) 
                --STU_GRADE           NUMBER(1)    
                --STU_CLASS           CHAR(1)      
                --STU_GENDER          CHAR(1)      
                --STU_HEIGHT          NUMBER(5,2)  
                --STU_WEIGHT          NUMBER(5,2)  
SELECT * FROM ENROL;


--사원의 이름, 부서명, 지역 검색하라
SELECT  E.FIRST_NAME || ' ' || LAST_NAME,
        D.DEPARTMENT_NAME,
        L.LOCATION_ID
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND D.LOCATION_ID = L.LOCATION_ID;



SELECT DEPARTMENT_NAME,
        CITY,
        FIRST_NAME
FROM DEPARTMENTS DEP, LOCATIONS LOC, EMPLOYEES EMP
WHERE DEP.MANAGER_ID = EMP.EMPLOYEE_ID
AND DEP.LOCATION_ID = LOC.LOCATION_ID;

--지역번호 2500인 사원의 사원명, 부서명, 지역명을 검색
SELECT FIRST_NAME,
        DEPARTMENT_NAME,
        CITY
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS LO
WHERE E.DEPARTMENT_ID=D.DEPARTMENT_ID
AND D.LOCATION_ID=LO.LOCATION_ID
AND LO.LOCATION_ID=2500;


--직군 AD_VP, IT-PROG인 사원의 사원명, 부서명, 직군명(JOB_TITLE)을 검색

SELECT  FIRST_NAME,
        DEPARTMENT_NAME,
        CITY,
        JOB_TITLE,
        E.JOB_ID
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS LO, JOBS J
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND d.location_id = lo.location_id
AND e.job_id = j.job_ID
AND E.JOB_ID IN('AD_VP','IT_PROG')
ORDER BY 2 DESC;

SELECT JOB_ID FROM EMPLOYEES;

--3. NOT-EQUAL JOIN : WHERE절에 조인조건(=) 연산자 이외의 비교 연산자를 사용하는 경우
--                    NOT-EQUAL JOIN은 중복되는 컬럼이 있으면 안된다.
--                    즉, 기본키와 외래키 관계가 아닌 열 값들의 의미있는 관계로 조인함
--                    

--학생번호, 이름, 학과, 학년, 반, 점수 검색
SELECT  S.STU_NO,
        SUB_NO,
        STU_NAME,
        STU_DEPT,
        STU_CLASS,
        ENR_GRADE,
        SCORE_NAME
FROM STUDENT S, ENROL E, GRADE G
WHERE S.STU_NO = E.STU_NO
AND ENR_GRADE BETWEEN SCORE_FROM AND SOCRE_TO;

SELECT * FROM STUDENT;
SELECT * FROM ENROL;
SELECT * FROM GRADE;



--Smith 매니저의 사원명
SELECT manager_id
FROM employees
WHERE last_name='Smith';

SELECT FIRST_NAME, LAST_NAME FROM EMPLOYEES
WHERE EMPLOYEE_ID=146 OR employee_id =148;

--** 4. Self Join : 자신과 같은 테이블이 두개인 것처럼 자기 자신의 테이블과 조인하는 것
SELECT * FROM EMPLOYEES;

SELECT  E.EMPLOYEE_ID 사원번호,  
        E.LAST_NAME 사원명,
        E.MANAGER_ID 관리자번호,
        M.EMPLOYEE_ID 관리자사원번호,
        M.FIRST_NAME 관리자명
FROM EMPLOYEES E, EMPLOYEES M --같은 릴레이션
WHERE E.MANAGER_ID = M.EMPLOYEE_ID
AND E.LAST_NAME='Smith';

--Steven 사원하고 같은 부서에 근무하는 사원 검색
--1)
SELECT DEPARTMENT_ID
FROM EMPLOYEES
WHERE FIRST_NAME = 'Steven'; --90,50 E
--2)
SELECT FIRST_NAME
FROM EMPLOYEES
WHERE DEPARTMENT_ID=90 OR DEPARTMENT_ID=50; -- M
--1+2)
SELECT  M.FIRST_NAME,
        M.DEPARTMENT_ID
FROM EMPLOYEES E, EMPLOYEES M
WHERE E.DEPARTMENT_ID = M.DEPARTMENT_ID
AND E.FIRST_NAME='Steven'; -- 스티븐과 같은 조건


SELECT SALARY FROM EMPLOYEES
WHERE FIRST_NAME = 'Neena';

SELECT FIRST_NAME FROM EMPLOYEES WHERE SALARY > 17000;

--Neena 연봉을 많이 받는 사원 건색
SELECT  E.SALARY,
        M.FIRST_NAME
FROM EMPLOYEES E, EMPLOYEES M
WHERE M.SALARY > E.SALARY
AND E.FIRST_NAME='Neena'
AND E.FIRST_NAME<>m.FIRST_NAME;

--출력을 부서명
SELECT  M.FIRST_NAME,
        D.DEPARTMENT_NAME
FROM EMPLOYEES E,EMPLOYEES M,DEPARTMENTS D
WHERE E.DEPARTMENT_ID = M.DEPARTMENT_ID
AND D.DEPARTMENT_ID=D.DEPARTMENT_ID
AND E.FIRST_NAME = 'Steven';

SELECT * FROM EMPLOYEES;

SELECT EMPLOYEE_ID, FIRST_NAME, SALARY FROM EMPLOYEES;

--OUTER JOIN = 테이블이 조인될 때, 어느 한쪽의 테이블에는 해당하는 데이터가 있으나, 다른
--             테이블에는 없는 경우, 그 데이터는 출력되지 않는다. 그 문제를 해결하기 위한 조인
--             Right Out Join, Left Outer Join, Full Outer Join (NULL값 대체??)

SELECT DISTINCT DEPARTMENT_ID
FROM EMPLOYEES
ORDER BY DEPARTMENT_ID; -- 0~110번, NULL

SELECT * FROM DEPARTMENTS
ORDER BY DEPARTMENT_ID; --10~110번, 120번~270번 // 부서는 있는데 사원이 없는 경우

--LEFT OUTER
SELECT  FIRST_NAME,
        D.DEPARTMENT_ID,
        DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID --특정 컬럼이 NULL일지라도 다른 컬럼들을 출력하고 싶을 때 - OUTER JOIN 쓴다
ORDER BY DEPARTMENT_ID DESC;

--RIGHT OUTER
SELECT  FIRST_NAME,
        D.DEPARTMENT_ID,
        DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+) -- 부서가 없는 사원까지 검색
ORDER BY DEPARTMENT_ID DESC; 

--FULL OUTER
SELECT  FIRST_NAME,
        D.DEPARTMENT_ID,
        DEPARTMENT_NAME
FROM EMPLOYEES E FULL OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID; 
--*****(어려움)부서명, 지역, 부서관리자를 검색하세요.

--사원의 매니저 이름 출력
SELECT  E.LAST_NAME 사원,
        NVL(TO_CHAR(M.LAST_NAME), 'CEO') 매니저,
        E.MANAGER_ID,
        M.EMPLOYEE_ID
FROM EMPLOYEES E, EMPLOYEES M
WHERE E.MANAGER_ID(+) = M.EMPLOYEE_ID
AND M.LAST_NAME = 'King';

SELECT * FROM EMPLOYEES;
